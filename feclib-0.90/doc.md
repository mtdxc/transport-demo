前向擦除校正
## 简介
此代码实现了前向擦除校正。这意味着它不会定位传输过程中发生的错误，
但它会重新生成任何在途中丢失的数据包。
 
它由一个编码器和一个解码器组成。编码器被喂给数据流，并分解成数据包。
然后这些数据包可通过不可靠的传输机制发送，通常是 UDP。
然后解码器可从编码器发送的冗余数据包中重建丢失的数据包。
 
和其他实现一样，编码器将 n 个数据包的payload分成一组，然后在其中添加 k 个冗余数据包。
接收器一旦收到至少 n 个数据包后，就能启动重建任何丢失的有效负载。
 
我希望一切都尽可能干净，没有花哨的功能。
由于它是开源的，任何人都可以自由地改进他们认为合适的东西。
贡献应从本文档末尾的待办事项列表开始。
 
我的本意是可用在那些没有后备信道（no back channel）的情况下，例如单向卫星链路。
因此，如库已经恰当配置，将恢复所有数据，即使由于雷暴等外部事件导致许多兆字节的数据丢失。
 
## 参数
此实现使用带矩阵band matrices（而不是 Van Der Monde 矩阵）以提高性能。它用途极为广泛，因为它允许您
设置以下参数：

- *s* 每个数据包的大小，不包括包头。（见下文 5）。
- *n* 分组数据包的数量。这决定延迟，
比如接收者最坏情况下，将不得不等到收完全组数据后，才有足够数据来输出第一个数据包。
除非您有延迟或内存问题，否则您可以将 n 设置为您发送的数据包数（见下文 3）
- *k* 每组发送的冗余包数。
k / (n + k) 最好比数据包丢失率还高。注意 k 冗余数据包的访问非常频繁，因此建议 k * s 应该小于物理内存 (RAM)。另请注意，随着 n 越来越小，失去其中 k 个数据的几率就会增加（特别是有突发丢失情况），因此 n 应尽可能大。通常是 k * s 将等于可能丢失的最大预期数据量。
也许有人会写一个函数，使用概率模型来求出最小的合适的k值...
- w 带band矩阵中带宽度。w越大，所需的处理能力就更多。通常 40 是一个很好的默认值。不幸的是，当您丢失了一个数据包和专栏中的所有 40 个冗余数据包时，重建将失败。幸运的是这 41 个数据包在 k + n 个数据包中丢失伪随机分布是比较小的，所以这种情况发生的可能性不大。
- g 伽罗华域的大小为2^g 。计算时间随 g 线性增加（和其他 O(1) 实现不同）。
因为一个字段只有 1 个元素而没有乘法逆，找不到的概率
当我们有 k - i 行可供选择时，spil 元素是2 ^ (-g * (k - i))。
所以 g 的一个好的值是 2、3 或 4。
s 必须是 g * 4 的倍数。
- b 编码器应该限制输出的每秒比特数，这可以防止网络过载。将其设置为 0，意味着它应该尽快发送。

## 函数
```
fecEncoder *NewFecEncoder(void *userData,
  size_t (*userSend)(void *buf, size_t size, size_t count, void *userData),
  char **errorMessage,
  int s, int n, int k, int w, int g, int b);
```

如果它返回 NULL，则发生错误。如果您在中传递了一个非 NULL 值的errorMessage, 
*errorMessage 将指向一个字符串，向您描述出错信息。
```
void FecEncode(fecPayload *buf, fecEncoder *f);
```
FecEncode 必须被调用 n 次（或其倍数），否则不会发送冗余数据。
```
void DeleteFecEncoder(fecEncoder *f);
```

```
typedef struct fecDecoder；
 
fecDecoder *NewFecDecoder(void *userData,
  void (*userReceive)(void *userData, __int64_t position, fecPayload *buf, int len)
);
 
size_t FecDecode(void *buf, size_t size, size_t count, fecDecoder *f);
 
void FlushFecDecoder(fecDecoder *f);
```
如果解码器具有最大可能的数据量，则纠错效果最好。
因此你应调用 flush 命令来表示不再期望任何数据，例如在超时之后。
```
void DeleteFecDecoder(fecDecoder *f);
```
 
## 待办事项列表
- 实施子渠道 目前我们发送一个非常大的标题包。因为我们在接收方需要它，它必须与每个包一起发送。
建议实现一个子通道来消耗更少的带宽，来发送20奇数控制信息字节：
现在标头是例如 2 个字节。
发送的第一个字节很简单模2 ^ 8 计数器。
第二个字节将包含 1 个字节控制数据，如果第一个字节小于 20，则为校验和字节
否则。此校验和方案还可以使用 Galois Fields 和 Gaussian消除，但必须选择它的参数，以便它仍然可以运行
在最坏的错误率下。
- 优化 
- 数据包校验和 让库发送自己的校验和以防UDP校验和仍然会让一些坏数据包通过。
- 非场环 很有可能存在一些不是原始的多项式，结果环不是域，而是大部分环都是可翻转的，可以更快地操纵它们手术。这需要调查。
- i的溢出 如果发送超过20亿个包，问题可能发生。我们需要解决这个问题。
 